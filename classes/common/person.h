#ifndef CLASSES_COMMON_PERSON_H_
#define CLASSES_COMMON_PERSON_H_

#include <iostream>
#include <memory>
#include <string>
#include <type_traits>
#include <vector>

#include "classes/common/book.h"
#include "classes/common/concepts.h"

// forward declaration
// to resolve circular dependency
class Book;

class Person : public std::enable_shared_from_this<Person> {
  // public: accessible by everyone
 public:
  Person(const std::string& name, const int age,
         const std::vector<std::weak_ptr<Book>>& publications);

  // delegating constructors
  Person(const std::string& name);
  Person(const std::string& name, const int age);

  // 1~6 could be automatically generated by the compiler:
  // 1. default constructor: no arguments
  Person();

  // 2. copy constructor
  // pass by read-only reference
  // trailing `noexcept` keyword: this function does not throw exceptions
  Person(const Person& another) noexcept;

  // 3. move constructor
  // pass by rvalue reference
  Person(Person&& another) noexcept;

  // 4. destructor
  // leading `virtual` keyword: non-static function that supports dynamic
  // dispatch, whose behaivor can be overriden in derived classes
  virtual ~Person();

  // 5. copy assignment operator
  // pass by read-only reference
  Person& operator=(const Person& another) noexcept;

  // 6. move assignment operator
  // pass by rvalue reference
  Person& operator=(Person&& another) noexcept;

  // bool conversion operator
  // leading `explicit` keyword: this function can only be used in:
  // - direct-initialization
  // - explicit type conversion
  virtual explicit operator bool() const noexcept;

  // std::string conversion operator
  // trailing `const` keyword: this function does not modify class data members
  virtual operator std::string() const noexcept;

  virtual const std::string PublicationsString() const;

  // getters and setters
  const std::string name() const;
  void name(const std::string& new_name);

  const int age() const;
  void age(const int new_age);

  std::vector<std::weak_ptr<Book>> publications() const;
  void publications(const std::vector<std::weak_ptr<Book>>& new_publications);

  void AddPublication(const std::shared_ptr<Book>& new_publication);
  void RemovePublication(const std::shared_ptr<Book>& rm_publication);
  void ClearPublications();

  // protected: accessible by itself and derived classes
 protected:
  std::string name_;
  int age_;
  std::vector<std::weak_ptr<Book>> publications_;

  // friends
 public:
  // std::ostream insertion operators
  // leading `friend` keyword: this function
  // - is a non-member function
  // - have access to the class's private members
  friend std::ostream& operator<<(std::ostream& os, const Person& person);

  // using C++20 concepts
  // template friends should be defined in the header file for implicit
  // instantiations
  template <classes::common::ElementContainer<Person> Container>
  friend std::ostream& operator<<(std::ostream& os, const Container& people) {
    os << "People {" << std::endl;
    for (const auto& person : people) std::cout << "  " << person << std::endl;
    os << "}" << std::endl;
    return os;
  }

  template <classes::common::ElementPtrContainer<Person> PtrContainer>
  friend std::ostream& operator<<(std::ostream& os,
                                  const PtrContainer& people) {
    os << "People {" << std::endl;
    for (const auto& person : people) {
      std::cout << "  ";
      if constexpr (std::is_same_v<typename PtrContainer::value_type,
                                   std::unique_ptr<Person>>) {
        os << *person << std::endl;
      } else if constexpr (std::is_same_v<typename PtrContainer::value_type,
                                          std::shared_ptr<Person>>) {
        os << *person << std::endl;
      } else if constexpr (std::is_same_v<typename PtrContainer::value_type,
                                          std::weak_ptr<Person>>) {
        if (!person.expired()) os << *person.lock() << std::endl;
      }
    }
    os << "}" << std::endl;
    return os;
  }
};

#endif  // CLASSES_COMMON_PERSON_H_
